class PromptManage(object):
    """
    prompt有关
    """
    @staticmethod
    def chat_template_to_prompt(messages, template):
        result = ""
        if template=='qwen':
            result += "<|im_start|>system\nYou are a helpful assistant.<|im_end|>\n"
        # elif template=='deepseek':
        #     result += "<｜begin▁of▁sentence｜>"
        total_step = len(messages)
        for i, message in enumerate(messages):
            if template == 'internlm':
                result += ('<|im_start|>' + message['role'] + 
                        '\n' + message['content'])
                if i+1 != total_step:
                    result += '<|im_end|>\n'
                elif message['role'] == 'user':
                    result += '<|im_end|>\n<|im_start|>assistant\n'
            elif template=='deepseek':
                if message['role']=='user':
                    result += 'User: ' + message['content'] + '\n\n'
                elif message['role']=='assistant':
                    result += 'Assistant:' + message['content'] + '<｜end▁of▁sentence｜>'
                elif message['role'] == 'system':
                    result += message['content'] + '\n\n'
                if i+1 == total_step and message['role'] == 'user':
                    result += 'Assistant:'
            elif template=='qwen': 
                if message['role'] == 'user':
                    result += f"<|im_start|>user\n{message['content']}<|im_end|>\n"
                elif message['role'] == 'assistant':
                    result += f"<|im_start|>assistant\n{message['content']}<|im_end|>\n"
                if i+1 == total_step and message['role'] == 'user':
                    result += "<|im_start|>assistant\n"
            elif template=='deepseek3':
                if message['role'] == 'user':
                    result += f"<｜User｜>{message['content']}"
                elif message['role'] == 'assistant':
                    result += f"<｜Assistant｜>{message['content']}<｜end▁of▁sentence｜>"
                if i+1 == total_step and message['role'] == 'user':
                    result += "<｜Assistant｜>"
            else:
                raise NotImplementedError
        return result

    @staticmethod
    def build_local_prompt_str(state: str, related_theorems: list[dict['str', 'str']]) -> str:
        theorems_str = PromptManage.build_theorems_str(related_theorems)
        prompt = f"Please generate a tactic in lean4 to solve the state.\nHere're some theorems that may be helpful:\n{theorems_str}\nSTATE:\n{state}\nTACTIC:\n"
        prompt = PromptManage.chat_template_to_prompt(
            [{'role': 'user', 'content': prompt}], 'deepseek'
        )
        return prompt
    
    @staticmethod
    def build_local_incontext_prompt_str(incontext: str, state: str, related_theorems: list[dict['str', 'str']],template: str = 'deepseek'):
        if related_theorems is not None:
            theorems_str = PromptManage.build_theorems_str(related_theorems)
        prompt = """In Lean, a formal proof is a fully constructed proof term that is type-checked and verified by the kernel. It represents a complete and correct derivation of a proposition.

The state after tactics refers to the intermediate proof state during tactic-based proof construction. It includes the list of remaining goals and the local context at that point.

Relationship:

- Tactics are procedural tools used to incrementally construct a formal proof.
- Each tactic transforms the current proof state by solving or reducing goals.
- The state after a tactic reflects the goals that still need to be proven after that tactic has been applied.
- Once all goals are solved, Lean assembles the underlying proof terms generated by the tactics into a complete formal proof.
- This final term is then type-checked by the kernel to ensure correctness.

In essence, the state after tactics shows where you are in the process of building a formal proof — it's a snapshot of what's left to do before the proof is complete.

Here is the FORMAL PROOF before the current state:
"""
        prompt += incontext
        prompt += "\nHere is the current STATE:\n"
        prompt += state
        prompt += "\n\n**Please generate a TACTIC in lean4 to solve the state.**"
        if related_theorems is not None:
            prompt += "\n\nAnd here're some theorems that may be helpful:\n"
            prompt += theorems_str
        prompt = PromptManage.chat_template_to_prompt(
            [{'role': 'user', 'content': prompt}], template
        )
        return prompt

    @staticmethod
    def build_claude_prompt_str(state, related_theorems):
        theorems_str = PromptManage.build_theorems_str(related_theorems)
        claude_prompt = f"""You are a Lean4 theorem prover assistant. Given the state and some potentially helpful theorems,
        generate ONE SINGLE tactic step that could help prove the goal. Output ONLY the tactic, nothing else.

        Relevant theorems:
        {theorems_str}

        Current state:
        {state}

        Output the tactic:"""
        return claude_prompt

    @staticmethod
    def build_theorems_str(related_theorems):
        return "\n\n".join([
            f"ID:{index}\nFormal name: {i['Formal name']}\nInformal name: {i['Informal name']}\nFormal statement: {i['Formal statement']}"
            for index, i in enumerate(related_theorems[:6])
        ])
    
    @staticmethod
    def build_claude_critic_str(state1, tactic, state2):
        return f"""You are a Lean4 theorem prover assitant. Given the state before tactic and current tactic. Tell whether the current tactic is trying to make repetitive or useless propositions. If so, output FALSE to deny it, otherwise output True. Please output ONLY TRUE or FALSE, nothing else.
        
        State before current tactic:
        {state1}

        Current tactic:
        {tactic}

        Your output:"""

if __name__=='__main__':
    state = "case:\nn : Nat"
    theorems = [{
        'Formal name': 'Test.test_thm_aux_1', 
        'Informal name': 'Test\'s First Theorem', 
        'Formal statement': 'thoerem_test_1'}, {
        'Formal name': 'Test.test_thm_aux_2', 
        'Informal name': 'Test\'s Second Theorem', 
        'Formal statement': 'thoerem_test_2'}]
    print(PromptManage.build_local_prompt_str(state, theorems))